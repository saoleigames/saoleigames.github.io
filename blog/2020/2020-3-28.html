<!doctype html>
<html>

<head>
<title>张晓雷的主页</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=no" />
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../css/indexCss.css" />
<!--href路径，当前路径直接复制到目录可用，当前不可用-->
</head>
<body>
<div id="body">
<div class="doc">
<div class="doc-title"><a href="../../index.html">返回主页</a></div>
<div class="doc-content">
    
<p>最近在电脑上装了个node.js，然后几行代码，让写东西变得简单一点点。就是通过node.js的文件读写能力，让它先读取现在写的文字，然后再读取一份文章的hmtl模版，把这片md文档转成html，和模版合并成一个新的文件。</p>
<p>最近还干了一件事，就是把去年做的俄罗斯方块又改进了一下。去年写到自己无法解决60帧和SRS旋转的问题，今年我在无聊的时候又琢磨了一下这些问题，突然感觉想通了。</p>
<p>我发现，60帧的问题真的很简单，我当时是脑子卡主了，或者说我被困在原来的思维模式里。我当时采用的思路我自己称它谓“被动刷新”，也就是说，当每次有操作或者程序进行向下循环的时候，程序会执行动作后面的图形函数。而如果要实现60帧，其实最简单的方法是“主动刷新”，也就是图形部分不管程序控制部分，只顾自己每<code>1000/60</code>毫秒执行一次，这样就实现了60帧，而且程序也会更简单。</p>
<p>踢墙部分我在一个B站的UP主那里得到了启示，理解了官方所谓的踢墙数据的原理。事实证明，使用官方的数据，踢墙会非常简单。</p>
<pre><code>J, L, S, T, Z Tetromino Wall Kick Data
        Test 1    Test 2    Test 3    Test 4    Test 5
0-&gt;R    ( 0, 0)    (-1, 0)    (-1,+1)    ( 0,-2)    (-1,-2)
R-&gt;0    ( 0, 0)    (+1, 0)    (+1,-1)    ( 0,+2)    (+1,+2)
R-&gt;2    ( 0, 0)    (+1, 0)    (+1,-1)    ( 0,+2)    (+1,+2)
2-&gt;R    ( 0, 0)    (-1, 0)    (-1,+1)    ( 0,-2)    (-1,-2)
2-&gt;L    ( 0, 0)    (+1, 0)    (+1,+1)    ( 0,-2)    (+1,-2)
L-&gt;2    ( 0, 0)    (-1, 0)    (-1,-1)    ( 0,+2)    (-1,+2)
L-&gt;0    ( 0, 0)    (-1, 0)    (-1,-1)    ( 0,+2)    (-1,+2)
0-&gt;L    ( 0, 0)    (+1, 0)    (+1,+1)    ( 0,-2)    (+1,-2)</code></pre><p><a href="https://harddrop.com/wiki/SRS">数据来源</a></p>
<p>上面是<code>J,L,S,T,Z</code>方块的踢墙数据，左边的<code>0-&gt;R</code>代表了方块从一个状态到另一个状态，其实网站已经给出了图示，一看便知。<code>0-&gt;R</code>表示方块从默认状态顺时针旋转90度, <code>R-&gt;0</code>表示相反操作。把这个数据写入算法时唯一要改变的是把向左向右转换为对应到左边状态符号，当然可以简化成<code>0R</code>、<code>R0</code>。而后面的括号的数据，第一位代表横向，第二位代表纵向，假如在横向，<code>0</code>表示不动，<code>1</code>表示向右一格，<code>-1</code>表示向左一格。</p>
<p>每次旋转计算完后先对数据做一个判定，如果成功则旋转成功，如果失败则进入尝试计算。先计算出目前方块旋转采用的状态，获取对应的数据，在开始偏移之前，先保存一份未偏移的数据，然后开始偏移尝试。<code>Test 1</code> 可以不用，因为默认的旋转算法就采用中心旋转的，直接从<code>Test 2</code> 数据开始依次尝试，尝试成功，则完成旋转，如果尝试失败，则把先前保存的数据拷贝回去，然后继续尝试，如果机会全部用完仍然没有成功，则旋转失败。</p>
<p>用官方数据的版本非常简单，当然这是因为有人总结出了规律，由过程推导出结果，再由结果简化过程，这样写方块的人可以直接用结果，省去了计算的麻烦。我觉得这有点像圆周率，我们都知道圆周率大约是<code>3.1415926...</code>,我们可以把这个数据拿去就用，不存在任何问题，而我们大多数人并不知道圆周率是如何这样精确的计算出来的。这个踢墙的数据表也是这样的功能。</p>
<p>我最开始也自己实现了一个踢墙功能，现在想想觉得很有意思。我在写方块之前没有查过任何教程相关的东西，我是在实现了基本的功能以后才在网上询问一些问题，然后又做了一些补充和改进。当时我当时我并不知道踢墙和T-spin有关的东西，在了经过一番了解以后，我开始在原来的基础上尝试实现，可惜我理解的并不正确。</p>
<p>对于踢墙，我想的纯粹就是踢墙，如何把方块从界外偏移进来，当时并不知道还有官方数据这样的方法，我采用的策略就是计算偏移量。尤其是在实现长条旋转踢墙的时候，我可是费了一番功夫，我当时着重考虑的一种情况是：</p>
<p>假如一根固定长条在区域的中间位置一柱擎天，然后一根移动的长条紧紧的贴着，突然，贴着的这个长条突然决定旋转方向，那么该如何计算贴着的这根长条的偏移方向，还有偏移量？</p>
<p>因为此时旋转的长条会和固定的长条呈十字交叉的状态，你就要计算移动的长条是向左还是向右，还有要偏移多少。当时没有踢墙数据，只能通过计算来实现。我采取的策略是，给旋转的长条计算中心，通过中心和重叠的区域来实现方向的判定，然后再根据中心计算出需要偏移的格数。</p>
<p>当时实现这个功能还是破让我高兴的，而如今，发现了更简单更合理的写法，顿时觉得方块这东西太简单了，也就没有了解决问题的喜悦感了。</p>
<p>尤其是60帧的问题，这让我不禁在想，是不是许多其它的问题也是这样的——如果思维方式错误，问题就会变的很复杂，而一旦掌握正确的方式，也许问题又惊人的简单。可是我对这样简单的问题的认识过程，中间竟然间隔1年。时间是宝贵的，如果对每个问题的认识的进步都需要耗费如此之久的话，那么可能许多问题真到了理解的那一天，却又没有意义了。</p>
<p>想想就让人沮丧，因为很有可能，在未来的某一天，突然发现，原来自己一直都是错的，自己只是陷入了一个错误的思维模式。</p>

</div>
</div>
</div>
</body>
</html>