昨晚，根据官方提供的踢墙数据，我写了一个新的踢墙功能，替换掉原来的。有点感叹，和官方提供数据的版本比，我原来那个真的是有点复杂，而且还有不少问题。

我把我之前实现的那个版本的代码贴过来，它们虽说已经没用了，但是当时写的时候可是费了一番功夫。

我当时写的时候，对俄罗斯方块的理解还是基于我小时候玩的国产掌机上，完全不懂踢墙和T-spin等概念，在基本实现我想象中的方块以后，才慢慢开始深入俄罗斯方块。不过现在我仍然算不上会玩俄罗斯方块，事实上我玩的很烂。

在当时没有踢墙数据的时候，我是如何去实现踢墙呢？

我当时是把所有的问题分开考虑的，先考虑踢墙的事情，然后在考虑踢方块的问题。

踢墙顾名思义，就是遇到方块旋转出界的时候把方块偏移回框内，踢方块就是当遇到方块和其它方块重贴的时候，如何把移动的方块从固定的方块里偏移出来。

我其中着重考虑了比如一根柱子一柱擎天，而另一个移动的长条紧紧的贴近，这时候再旋转，当两个方块十字相交的时候，该如何判定方块是向左偏移还是向右偏移。
因为这个时候，长条的坐标已经和柱子的坐标相交，需要判定柱子在哪个方向，以及应该偏转多少合适。

我采用的策略是，给长条求中心，对比中心和重合的坐标来判定长条应该偏转的方向。

```
//获取方块的左右边界值
let [tmin, tmax] = getArrMixAndMax(moving, 1, 2);
//方块的中心数值，比如长条 1,2,3,4, 计算(1 + 4) / 2 === 2.5
let tcross = (tmin + tmax) / 2;
//出界方块的中心, 比如出界 3,4 计算 ： (3 + 4) / 2
```
这个方法事实证明是不错的，在写后的一年里，虽然我并不经常玩，但偶尔想起来还是会玩，但从来没发现有什么问题。

但它终究不是一个正确的解决方式，这也是我为什么现在又去实现一个基于官方数据的踢墙。

基于官方数据的这个版本惊人的简单，官方非常聪明的把各种情况作了一个列表，这样一旦标准的旋转失败，你就开始挨个尝试它提供的对应的一组偏转坐标，如果尝试成功，旋转结束，如果这一组偏转数据全部失败，则旋转失败。




```
    /*
    触底旋转向上偏移，主动偏移
    如果采用被动偏移，方块落地以后，偏转数据会超出table范围，收集数据时会导致索引超出范围问题
    */
   let dp = 24;
    
   for (let i of moving) {
       if (i[0] > dp) {
           dp = i[0];
       }
   }

   dp = dp - 24;
   while (dp --) {
       moveOneStep(moving, "up");
   }

   //旋转完成，开始后续偏转处理，以及判定旋转是否成功
   let outsideRowList = [];
   let outsideVertList = [];

   //收集横向重叠数据
   for (let i of moving) {
       if (i[1] < 0 || i[1] > 9 || table[i[0]][i[1]] < 0) {
           outsideRowList.push(i);
       }
   }

   let rowLen = outsideRowList.length;
   //初步判断是否需要左右偏转
   if (rowLen) {
       //获取方块底部index
       let deepIndex = getArrMixAndMax(moving, 0, 1);
      
       let deepWidth = 0;
       //统计底部宽度
       moving.forEach((i)=>{
           if (i[0] === deepIndex) {
               deepWidth += 1;
           }
       })
       
       //获取方块的左右边界值
       let [tmin, tmax] = getArrMixAndMax(moving, 1, 2);
       //方块的中心数值，比如长条 1,2,3,4, 计算(1 + 4) / 2 === 2.5
       let tcross = (tmin + tmax) / 2;
       //出界方块的中心, 比如出界 3,4 计算 ： (3 + 4) / 2

       let trc = rowLen === 1 
            ? outsideRowList[0][1] 
            : outsideRowList.reduce((a,b) => a[1] + b[1]) / rowLen;

       //排除正下方的方块，最终确定是否需要偏移
       if (!((tcross - trc === 0) 
            || (rowLen === 1 && outsideRowList[0][0] === deepIndex && deepWidth === 1))) {

           //判断偏移方向
           //向右偏移

           if (tcross - trc > 0) {
               //长条特殊处理
               if (tetrisType === 2) {
                   if (tcross - trc <= 1) {
                       moveOneStep(moving, "right", 2);
                       //moveOneStep(moving, "right");
                   } else {
                       moveOneStep(moving, "right");
                   }
               //一般偏移
               } else {
                   moveOneStep(moving, "right");
               }

           } else {
               //向左偏移
               if (tetrisType === 2) {
                   if (trc - tcross <= 1) {
                       moveOneStep(moving, "left", 2);
                       //moveOneStep(moving, "left");
                   } else {
                       moveOneStep(moving, "left");
                   }
               //一般偏移
               } else {
                   moveOneStep(moving, "left");
               }
           }
       }
   }
    
    //收集下方重叠数据，moving此时的数据已经变动，所以收集数据要分开。
    
   for (let i of moving) {
       if (i[1] < 0 || i[1] > 9 || table[i[0]][i[1]] < 0) {
           outsideVertList.push(i);
       }
   }

   
   //判断是否需要向上偏移。判断是否收集到上移的数据，判断下方是否接触。
   
   if (outsideVertList.length && checkCanTouch()) {
       let [vmin, vmax] = getArrMixAndMax(outsideVertList, 0, 2);
       for (let i = vmin ; i < vmax + 1; i++) {
           moveOneStep(moving, "up");
       }
   }
   
   //最终判定旋转是否成功，如果失败，取消旋转
   for (let i of moving) {
       if (i[1] < 0 || i[1] > 9 || table[i[0]][i[1]] < 0) {
           straightStage = Tstage;
           copyAtoB(old, moving);
           return; // 程序退出，旋转失败
       }
   }

   //旋转成功！更新数据
   refreshData();
   copyAtoB(moving, old);
```